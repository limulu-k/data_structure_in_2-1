## Tree

### 정의

일종의 collection

none linear data structure. -> parent-child 관계

![4-14-2](https://i.namu.wiki/i/DO0g6Xy9zt3-mYYopfUvYItrpt1k2Hyq0lw5QW5mgUgsdsAVGLQi_69ptrE5zz9Iq3veJsm1pKm5Q0PnAzXLApwhSMDYr14q_Tvbl7RypASbGcX8pYLzb1LyTmW8B9AXmsv-eLMgE8Y_9um_GjxusA.webp)

- 그래프의 일종
- 트리가 비지 않았을 때, root라는 parent가 없는 노드가 존재한다.
- root를 제외하고 모든 노드는 유니크한 parent 노드 w가 하나 존재하며, 해당 노드는 w의 child 이다.
- root에서 특정 노드로 가는 유니크한 path가 존재한다
- 사용 예: 조직도, 파일 시스템

| 트리 용어                | 설명                                   |
| ------------------------ | -------------------------------------- |
| root                     | paret가 없는 노드                      |
| internal node            | child를 최소 하나 갖는 노드            |
| external node(leaf node) | child를 갖지 않는 노드                 |
| ancestors                | parent와 parent의 parent, ,,,,         |
| descendants              | child와 child의 child, ,,,,            |
| subtree                  | 노드와 descendants로 이루어진 트리     |
| ordered tree             | 각 child에 의해 선형적으로 정렬된 트리 |



### Tree ADT

- node를 position으로 정의

- Generic methods:

   - integer size()
   - boolean isEmpty()
   - Iterator iterator()
   - Iterable positions()

   ```java
   // list는 literable하다 책 secssion 7-3 ~ 7-4
   List<Integer> as = new List({1,2,3,4,5});
   Iterator<Integer> iter = as.iterator();
   Iterale<Integer> iter = as.subList(0,as.size());
   while(iter.hasNext())
       System.out.println(iter.next());
   for(int i : as)
       System.out.println(i);
   ```

- Accessor methods:

   - position root()
   - position parent(p)
   - Iterable children(p)


- Query methods:
  - boolean isInternal(p)
  - boolean isExternal(p)
  - boolean isRoot(p)

- Update method:
  - element replace (p, o)



```pseudocode
Algorithm depth(T)
    d <- 0
    for each node v in T do
        if T.isExternal(v) then
            d <- max(d, depth(T,v))
	return d
```





```pseudocode
Algorighm height(T)
	h <- 0
	for reach node v in I do // <- n
		if T.isExternal(v) ten
			h <- max(h,depth(T,v)) // <- n
	return h
```

=> O(n<sup>2</sup>)



### Preorder Traversal

- 자식보다 부모를 먼저 방문

```pseudocode
Algorithm preOrder(v) 
	visit(v) 
	for each child w of v do
		preorder (w)
```

ex) Table of Content

```java
public static<E> void printPreoderIndent(Tree<E> T, Position<E> p, int d){
    System.out.println(space(2*d)+p.getElements());
    for(Position<E> tmp : T.children(p))
        printPreoderIndent(T, p, d+1);
}
```



### Postorder Traversal

- 부모보다 자식을 먼저 방문
- DFS

```pseudocode
Algorithm postOrder(v) 
	for each child w of v do
    	postOrder (w) 
    visit(v)
```

ex) Computing Disk Space

```java
public static int diskSpace(Tree<Integer> T, Position<Integer> p){
    int subtotal = p.getElement();
    for (Position<Integer> tmp : T.children(p))
        subtotal += diskSpace(T, tmp);
    return subtotal;
}
```



### Breath-First(Level-order) Traversal

```pseudocode
Algorithm Breadthfirst()
	Initialize queue Q to contain root()
	While Q not empty do
		p = Q.dequeue()
		perform the "visit" action for position p
		for each child c in children(p) do
			Q.enqueue(c) // add p's children to the end of the queue for later visits
```



### Binary Tree

#### Proper Tree

- 모든 자식이 있는 트리는 자식이 2개을 가져야함

#### Full (Binary) Tree(정 이진 트리)

- 모든 잎이 같은 레벨이고 모든 비잎 노드에 두 개의 자식이 있는 이진 트리

  => 모든 external node는 레벨이 같고, 모든  internal node는 2개의 자식을 갖는다.

- 총 2<sup>n+1</sup>의 노드가 존재한다.

#### Complete (Binary) Tree(완전 이진 트리)

- 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있음
- 마지막 레벨의 모든 노드는 가능한 한 가장 왼쪽에 있다.



#### Properties of Binary Trees

| 변수          | 설명                 |
| ------------- | -------------------- |
| n             | 노드의 갯수          |
| n<sub>e</sub> | external 노드의 갯수 |
| n<sub>i</sub> | internal 노드의 갯수 |
| h             | 높이                 |

##### 일반적인 트리의 properties:

- h  + 1 ≤ n ≤ 2<sup>h+1</sup> - 1
- 1 ≤ n<sub>e</sub> ≤ 2<sup>h</sup>
- h ≤ n<sub>i</sub> ≤ 2<sup>h - 1
- log<sub>2</sub>(n+1) - 1 ≤ h ≤ n - 1



##### Proper tree에서의 properties:

- 2h + 1 ≤ n ≤ 2<sup>h+1</sup>-1
- h + 1 ≤ n<sub>e</sub> ≤ 2<sup>h</sup>
- h ≤ n<sub>i</sub> ≤ 2<sup>h</sup>-1
- log<sub>2</sub>(n+1) - 1 ≤ h ≤ n-1
- n<sub>e</sub> = n<sub>i</sub> + 1



#### Binary Tree ADT

- Inorder : L V R
- Preorder : V L R
- Postorder : L R V



##### Inorder

- x(v) = inorder rank of v
- y(v) = depth of v

```pseudocode
Algorithm inOrder(v) 
	if hasLeft(v) 
		inOrder(left(v)) 
	visit(v) 
	if hasRight(v) 
		inOrder(right(v))
```



##### Preorder

```pseudocode
Algorithm inOrder(v) 
	visit(v) 
	if hasLeft(v) 
		inOrder(left(v)) 
	if hasRight(v) 
		inOrder(right(v))
```



##### Postorder

```pseudocode
Algorithm inOrder(v) 
	if hasLeft(v) 
		inOrder(left(v)) 
	if hasRight(v) 
		inOrder(right(v))
	visit(v) 
```



#### Example

##### Print Arithmetic Expressions

```pseudocode
// Inorder
Algorithm printExpression(v) 
	if hasLeft(v)
		print("(")
		inOrder(left(v))
	print(v.element()) 
	if hasRight(v) 
		inOrder(right(v)) 
		print(")")
```



##### Evaluate Arithmetic Expressions

```pseudocode
// Postorder
Algorithm evalExpr(v) 
	if isExternal(v) 
		return v.element() 
	else 
		x <- evalExpr(leftChild(v)) 
		y <- evalExpr(rightChild(v)) 
		<> <- operator stored at v 
		return x <> y
```



#### Linked List-Based Structure

- Element
- Parent node
- Sequence of childre nodes



#### Array-Based Structure of Binary Tree

- root를 0에 넣을 수도 1에 넣을 수 도 있음
  - 0부터 채우는 경우
    - rank(root) = 0
    - rank(left_node) = 2*rank(parent(node)) + 1
    - rank(right_node) = 2*rank(parent(node)) + 2
    - rank(parent(node)) = round(rand(node) / 2) - 1
  - 1부터 채우는 경우
    - rank(root) = 1
    - rank(left_node) = 2*rank(parent(node))
    - rank(right_node) = 2*rank(parent(node)) + 1
    - rank(parent(node)) = (int)(rand(node) / 2)





## Priority Queues

### ADT

(데이터 + 우선순위) = 엔트리(entry(k, v)) 큐에 저장, 키값이 작을수록 우선순위가 높음

- insert(k, v) : 우선순위(k)와 데이터(v) 저장
- removeMin() : prioirt가 가장 높은 엔트리 return&remove
- min() : prioirt가 가장 높은 엔트리 return
- size(), isEmpty()



### Total Order Relation(전순서 관계)

임의의 두 원소를 비교할 수 있는 부분 순서 관

- Comparability(완전성) : 항상 `x ≤ y` 이거나 `y ≤ x`이다.
- Antisymmetric(반대칭성) : `x ≤ y`이고 `y ≤ x`라면 `x = y`이다.

- Transitive(추이성) : `x ≤ y`이고 `y ≤ z`라면 `x ≤ z` 이다.



### Entry ADT

- simply a key-value pair

- function

  - getKey : return the  key for this entry

  - getValue : return the value associated with this entry



### Java.lang.Comparable

객체 비교용 인터페이스

```java
public interface Comparable<T> {
	int compareTo(T o)
}
```

 

```java
// int -> integer
Integer[] boxed_xs = Arrays.stream(xs).boxed().toArray(Integer[]::new)
```



### Comparator

```java
public interface Comparator<T> {
	int compare(T o1, T o2)
}
```



### Priority Queue Sorting

- 일종의 out-place sorting임

- Selection Sort와 비슷해짐 sortedlist던 unsortedlist던 결국 O(n<sup>2</sup>)임





## Heap

- binary tree storing keys at its nodes and stisfying the following properties
- Heap-Order Property : for every node v other than the root `key(v) >= key(parent(v))`
- Complete binary Tree Property : let h be the height of the heap
  - for i = 0,1,...,h-1 there are 2<sup>i</sup> nodes for depth i
  - 왼쪽으로 치우쳐져 있음

- Min Heap
  - `key(v) >= key(parent(v))`
- Max Heap
  - `key(v) <= key(parent(v))`



### UpHeap



### DownHeap





### Updating last Node

#### 추가하기 위한 last node 탐색	

1. Go up until a left child or the root is reached

   root 까지 탐색해야만 하는 이유는,만약 현재 h의 리프노드가 꽉찼을 때, 다음 h+1에 노드를 추가하기 위해 root까지 올라간 경우에도 left child 쪽으로 이동하여 노드를 추가해야한다.

2. If a left child is reached, go to the right child(go to sibling)

3. Go down left until a leaf is reached

=> O(logn)



#### 제거하기 위한 last node 탐색

1. Go up until a right child or the root is reached
2. If a left right is reached, go to the left child(go to sibling)
3. Go down right until a leaf is reached

=> O(logn)



### Vector-based Heap

- 시작 index가 1 일때
  - 필요 공간 : n+1
  - left child : 2*i
  - right child : 2*i + 1
  - parent node : i//2
- 시작 index가 0 일때
  - 필요 공간 : n
  - left child : 2*i +1
  - right child : 2*i + 2
  - parent node : (i-1)//2



### Max heap implementaion

1. 배열 생성, 데이터 삽입

2. root 노드를 기준으로 논리적인 추가 실행

3. 부모노드보다 추가한 노드가 크다면 부모노드와 바꿈

   -> root까지 상태 확인, 스와핑 실행

- min heap은 반대로



### Max heap elemenate max value

1. root 노드의 값과 배열의 마지막값을 스와핑

2. 자식노드가 크다면 더 큰 값을 부모노드와 스와핑

   -> leaf노드 까지 확인

- min heap elemenate min value 는 반대로





## Map

### ADT

- get(k) : k 에 해당하는 value return, 없을 시 null return
- put(k,v) : k에 해당하는 v가 있을시 예전값 return 후 해당 쌍 등록, 없을시 null return
- remove(k) : k에 해당하는 v가 있을 시 return 후 제거, 없을 시 null return
- size(), empty() : 키의 사이즈 return
- entrySet() : Map에서 모든 Entry(Key-Value 쌍)를 가져와 Set 객체로 return
- keySet() : Map의 모든 key를 가져와 Set 객체로 return
- values() : Map의 모든 v를 가져와 return



| Property                           | HashMap                                                     | TreeMap                                            | LinkedHashMap         |
| ---------------------------------- | ----------------------------------------------------------- | -------------------------------------------------- | --------------------- |
| order                              | no guarantee order<br />will remain constant<br />over time | sorted according<br />to the natural<br />ordering | insertion-order       |
| get / put <br />remove containsKey | O(1)                                                        | O(log(n))                                          | O(1)                  |
| Interfaces                         | Map                                                         | NavigableMap<br />Map<br />SortedMap               | Map                   |
| Null<br />values / keys            | allowed                                                     | only values                                        | allowed               |
| Implementation                     | buckets                                                     | Red-Black Tree                                     | double-linked buckets |



## Dictionaries

- get(k) : k 에 해당하는 entry return, 없을 시 null return
- getAll(k) : k 에 해당하는 전체 entry  리스트로 return, 없을 시 null return
- put(k,o) : k, o 쌍 entry로등록
- remove(e) : e에 해당하는 entry 제거
- entrySet() : 전체 entry 쌍 return
- size(), isEmpty() : size return



search table,hash search table, binary search table, 에이블트리?



## search table

- key 값으로 정렬된 sorted array로 구현한 map
- key 값은 직접 비교 or external comparator로 비교 가능해야함

**복잡도**

- get : O(log n) <= 2진탐색 복잡도
- put : O(n) <= worst case : n개, best case : 0개, ave case : n/2 개 쉬프트
- remove : O(n) <= worst case : n개, best case : 0개, ave case : n/2 개 쉬프트

**Algorithm**

```pseudocode
Algorithm BinarySearch(S, k, low, high) 
	if low > high 
		return null
	else
		mid <- (low+high) div 2 
		e <- S.get(mid)
		if k = e.getKey() then 
			return e
		else if k < e.getKey() then 
			return BinarySearch(S, k, low, mid-1) 
		else
			return BinarySearch(S, k, mid+1, high)
```



## Hash table

Hash Function : key값을 통해 해시 테이블 상의 인덱스(hash value) 생성

충돌이 일어나는거 처리

-> Entry가 아닌 Collection으로 저장 -> 같은 키값의 중복이 생격도 저장 가능

 => seperate chaining라고 함

A hash table for a given key type consists of 

- Hash Function
- Array(called "table") of size N <- **Bucket Array**라고 함

A hash function `h(x)` maps keys of a given type to integers in a fixed interval [0-N-1]

### Anatomy of Hash Function

**1. Hash code :**

​	h<sub>1</sub> : keys -> integers

​	 => hash value를 만들기 위한 integer 발생기

**2. Compression function :** 

​	h<sub>2</sub> : integers -> [0, N-1]

​	 => 0 ~ N-1 범위의 hash value 생성

**h(x) = h<sub>2</sub>(h<sub>1</sub>(x))**



#### Hash Code:

- **Memory address**
  
  - 데이터 저장된 주소를 활용 -> key 값으로 사용
- **Integer cast**
  
  - 키의 비트를 정수로 재해석
  - 정수 유형의 비트 수(int, float, etc)보다 작거나 같은 길이의 키에 적합
- **Component sum**
  
  - 키의 비트를 고정된 길이의 구성 요소(16, 32)로 분할하고 구성 요소를 합산.
  
  - 정수 유형의 비트 수(long, double)보다 크거나 같은 고정 길이의 숫자 키에 적합
  
  - 키 슬라이싱<br>
  
    ```java
    long key = 0x1234567890abcdefL;
    // f*8 32비트 and 연산으로 슬라이싱
    int low = (int)(0x0ffffffff & key); 		
    int high = (int)(0x0ffffffff & (key >>>32));
    // f*7 int 범위 내에서 가장 큰 값(0111 1111 1111 1111 1111 1111 1111 1111)
    int result = (low+high) & 0x7fffffff;		
    ```

- **evaluate the polynomial**

  - p(z) = a<sub>0</sub>+ a<sub>1</sub>z + a<sub>2</sub>z<sup>2</sup>+.....+a<sub>n-1</sub>z<sup>n-1

    => O(n<sup>2</sup>)

  - **Horner's rule** : p(z) = ((a<sub>3</sub>z + a<sub>2</sub>)z + a<sub>1</sub>)z + a<sub>0</sub>

    => O(n)

  - Espcially suitable for strings

​		=> english the choice z = 33 -> most 6 collisions on a set of 50000 words



#### Compression Funtion

- Division 
  - h<sub>2</sub>(y) = y Mod N
- MAD(Multiply, Add, Divide)
  - h<sub>2</sub>(y) = (ay + b) Mod N, 단 `a Mod N ≠ 0`
  - *단일 모듈러 연산보다 균일한 분포와 이로 인한 충돌 감소, 유연성이 좋다고함*



### Collision Handling

서로 다른 키값에 대해 동일한 h(x)가 생성될 때 충돌 발생

**Collision Handling Schemes**

- Separate Chaining

- Open Addressing

  - the dollinding item is placed in a different cell of the table

  - Linear Probing

  - Double Hashing



#### Separate Chaining

- 데이터를 collection으로 저장, 중복되는 hash code의 데이터를 같이 저장
- 별도의 메모리 공간이 필요해짐

**Implement by map**

```pseudocode
Algorithm get(k):
	return A[h(k)].get(k) 
Algorithm put(k,v): 
	t = A[h(k)].put(k,v) 
	if t = null then 
		n = n + 1 return t
Algorithm remove(k): 
	t = A[h(k)].remove(k)
	if t ≠ null then 
		n = n - 1 
	return t
```



























